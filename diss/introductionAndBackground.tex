\documentclass{Report}
\usepackage{framed}

\input{../proofs/header.tex}

\begin{document}
\abstract


    
To date, there has been limited work on the semantics of languages with polymorphic effect systems. The application, by Moggi, of strong monads to modelling the semantics of effects has become a mainstream concept in functional programming languages. This was improved upon by Lucasson (?) using a graded monad to model languages with a range of independent and dependent effects at an operational level. A categorical semantics for parametric polymorphism in types was first published by Reynolds (?) allowing a denotational analysis of languages including type parameters. There has been some work on polymorphism over the exception effect (which paper). Despite these works, there has been no work to date on the denotational semantics of languages with general parametric polymorphism over effects.

In this dissertation, I present several pieces of work. Firstly, I shall introduce a modern definition of a lambda-calculus based language with an explicit graded monad to handle a variety of effects. This calculus shall then be extended using polymorphic terms to yield a more general polymorphic-effect-calculus. I shall then give an indexed-category-based denotational semantics for the language, along with an outline of a proof for the soundness of these semantics. Following this, I shall present a method of transforming a model of a non-polymorphic language into a model of the language with polymorphism over effects.

The full proofs can be found online on my github repository (link), since due to the number of theorems and cases, the total size is well over 100 pages of definitions, theorems, and proofs.

\chapter{Introduction}
\section{What is Effect Polymorphism?}
Effect polymorphism is when the same function in a language can operate on values of similar types but with different effects. It allows the same piece of code to be used in multiple contexts with different type signatures. This manifests in a similar manner to type parameter polymorphism in system-F based languages. Consider the following Scala-style pseudo-code:

\begin{framed}
    \begin{framed}
        \begin{verbatim}
def check[E: Effect](
    action: Unit => (Unit;e)
): Unit; (IO, e) {
    val ok: Boolean = promptBool(
        "Are you sure you want to do this?"
    )
    If (ok) {
        action()
    } else {
       abort()
    }
}  
            \end{verbatim}
    \end{framed}

    \begin{framed}
        \begin{verbatim}
check[IO, RealWorld](() => check[RealWorld](FireMissiles))
check[Transaction](SendMoney(Bob, 100, USD))
check[Exception](ThrowException(“Not Aborted”))
        \end{verbatim}
    \end{framed}
\end{framed}

In this case, we are reusing the same “check” function in three different cases with three different effects in a type safe manner. “Check” is polymorphic in the effect parameter it receives. To analyse this language, it would be useful to have precision to compare different effects.

\section{An Introduction to Categorical Semantics}
When we specify a denotational semantics of a language in category theory, we look to find a mapping of types and typing environments to objects in a given category.

\begin{align}
    A: \type & \mapsto \deno{A} \in \obj \C \\
    \G & \mapsto  \deno{\G} \in \obj \C
\end{align}



Further more, instances of the type relation should be mapped to morphisms between the relevant objects.

\begin{align}
    \gtyperelation{v}{A} & \mapsto \C(\deno{\G}, \deno{A}) 
\end{align}

This should occur in a sound manner. That is, for every instance of the $\beta\eta$-equivalence relation between two terms, the denotations of the terms should be equal in the category.

\begin{align}
    \gberelation{v_1}{v_2}{A} & \implies \deno{\gtyperelation{v_1}{A}} = \deno{\gtyperelation{v_2}{A}}
\end{align}

To prove soundness, we induct over derivation of the $\beta\eta$-equivalence relation. In doing so, we need to prove a couple of properties which help prove cases. These are substitution and weakening. \todo{What do these do?}


\subsection{Arrows and Objects}
\subsection{Languages and Their Requirements}
One of the simplest, while still interesting, languages to derive a denotational semantics for is the simply typed lambda calculus (STLC). STLC's semantics require a cartesian closed category (see section \ref{CCC}).

Products are used to denote the lists of variable types in the typing environment, exponential objects model functions, and the terminal object is used to derive "points" (\todo{Terminology}) which represent the ground terms, such as the unit term, $()$, as well as the empty typing environment.

From this, we can specify what structures categories need to have in order to model more complex languages.
\begin{center}
    \begin{tabular}{|c|c|}
        \hline
        Language Feature & Structure Required \\
        \hline
        \hline
        STLC            & CCC \\
        \hline
        Single Effect   & Strong Monad \\
        \hline
        Multiple Effects & Strong Graded Monad \\
        \hline
        Polymorphism & Indexed Category \\
        \hline
    \end{tabular}
\end{center}


A single effect can be modelled using a strong monad, as shown by Moggi \todo{Reference}. The monad allows us to generate a unit effect and to compose multiple instances of the effect together in a way that intuitively matches the type system of a monadic language.

For more precise analysis of languages with multiple effects, we can look into the algebra on the effects. A simple algebra is a partially ordered monoid. The monoid operation defines how to compose effects, and the partial order gives a sub-typing relation to make programming more intuitive with respect to if statements. A strong graded monad allows us to model this algebra in a category theoretic way.

To express polymorphism over a property $P$, the language's semantics are expanded to use a new environment specifying the variables ranging over $P$ that are allowed in a given context. To model this, we can create a category representing the semantics of the non-polymorphic language at each given context, indexed by a base category which models the operations and relationships between the $P$-Environment. Morphism in the base category between environments correspond to functors between the semantic categories for the relevant environments. These functors can then be used to construct the semantics of polymorphic terms. \todo{Index diagram}


\chapter{Required Category Theory}

Before going further, it is assert a common level of category theory knowledge.

\section{Cartesian Closed Category}\label{CCC}

Recall that a category is cartesian closed if it has a terminal object, products for all pairs of objects, and exponentials.

\subsection{Terminal Object}
An object, $\1$, is terminal in a category, $\C$ if for all objects $X\in\obj\C$, there exists exactly one morphism $\term{X}: X \rightarrow \1$.

\subsection{Products}
There is a product for a pair of objects $X, Y\in\obj\C$ if there exists an object and morphisms in C:
\begin{tikzcd}
    X & \arrow{l}[swap]{\p} (X\times Y) \arrow [r, "\pp"] & Y
\end{tikzcd}

Such that for any other object and morphisms,

\begin{tikzcd}
    X & \arrow{l}[swap]{f} Z \arrow [r, "g"] & Y
\end{tikzcd}

There exists a unique morphism $\pr{f}{g}: Z \rightarrow (X\times Y)$ such that the following commutes:

\begin{tikzcd}
    & \arrow{dl}[swap]{f} Z  \arrow[d, "\pr{f}{g}"] \arrow [dr, "g"] & \\
    X & \arrow [l, "\p"] (X\times Y) \arrow{r}[swap]{\pp} & Y\\
\end{tikzcd}

\subsection{Exponentials}
A category has exponentials if for all objects $A, B$, it has an object $B^A$ and a morphism $\app: \B^A \times A \rightarrow B$ and for each $f: (A\times B)\rightarrow C$ in $\C$ there exists a unique morphism $\cur{f}: A \rightarrow C^B$ such that the following diagram commutes.

\begin{tikzcd}
    C^B \times B \arrow{r}{\app}& C\\
    A\times B\arrow{u}{\cur{f}\times \Id{B}} \arrow{ur}{f}    
\end{tikzcd}

\section{Co-Product}

\section{Functors}
A functor $F: \C \rightarrow \DC$ is a mapping of objects:
\begin{align}
    A\in\obj\C \mapsto FA \in \obj\DC
\end{align}

And morphisms:

\begin{align}
    f: \C(A, B) \mapsto F(f): \DC(FA, FB)
\end{align}

that preserves the category properties of composition and identity.

\begin{align}
    F(\Id{A}) & = \Id{FA} \\
    F(g\after f) & = F(g)\after F(f)
\end{align}

\section{Natural Transformations}

A natural transformation $\theta$ between to functors $F, G: \C \rightarrow \DC$ is a collection of morphisms, indexed by objects in $\C$ with  $\theta_A: F(A) \rightarrow G(A)$ such that following diagram commutes for each $f: A \rightarrow B \in \C$

\begin{tikzcd}
    F(A) \arrow{r}{\theta_A} \arrow{d}{F(f)}  & G(A) \arrow{d}{G(f)}\\
    F(B) \arrow{r}{\theta_B}& G(B)\\ 
\end{tikzcd}

\section{Monad}

A monad is famously "a monoid on the category of endofunctors". In less opaque terms, a monad is:

\begin{itemize}
    \item A functor from $\C$ onto itself. (An endofunctor) $T: \C \rightarrow C$
    \item A "unit" natural transformation $\point{A}: A\rightarrow T(A)$
    \item A "join" natural transformation $\mu_{A}: T(T(A)) \rightarrow T(A)$
\end{itemize}

Such that the following diagrams commute:

\paragraph{Associativity}
\begin{tikzcd}
    T(T(T(A)) \arrow{r}{\mu_{T(A)}} \arrow{d}{T(\mu_{A})} & T(T(A)) \arrow{d}{\mu_A} \\
    T(T(A)) \arrow{r}{\mu_A} & T(A)    
\end{tikzcd}


\paragraph{Left and Right Unit}
\begin{tikzcd}
    T(A) \arrow{r}{\point{T(A)}} \arrow{d}{T(\point{A})} \arrow{rd}{todo} & T(T(A)) \arrow{d}{\mu_A}\\
    T(T(A)) \arrow{r}{\mu_A} & T(A)
\end{tikzcd}



\section{Graded Monad}
A graded monad is a generalisation of a monad to be indexed by a monoidal algebra $E$. It is made up of:

\begin{itemize}
    \item An endo-functor indexed by a monoid: $\T{}{}: (\E, \dot\, \1)  \rightarrow [\C, \C]$
    \item A unit natural transformation: $\point{}: \Id{} \rightarrow \T{\1}{}$
    \item A join natural transformation: $\bind{\e_1}{\e_2}{}: \T{\e_1}{\T{\e_2}{}} \rightarrow \T{\e_1 \dot \e_2}{}$
\end{itemize}

Such that the following diagrams commute.:
\subsection{Left Unit}
    \begin{tikzcd}[ampersand replacement=\&]
    \tea \arrow[rd, "\Id{\tea}"] \arrow[r, "\T{\e}{\point{A}}"] \& \T{\e}{\T{\1}{A}} \arrow[d, "\bind{\e}{\1}{A}"] \\
    \& \tea
    \end{tikzcd}

\subsection{Right Unit}
    \begin{tikzcd}[ampersand replacement=\&]
    \tea \arrow[rd, "\Id{\tea}"] \arrow[r, "\point{\tea}"] \& \T{\1}{\T{\1}{A}} \arrow[d, "\bind{\1}{\e}{A}"] \\
    \& \tea
    \end{tikzcd}

\subsection{Associativity}
\begin{tikzcd}[ampersand replacement=\&]
    \T{\e_1}{\T{\e_2}{\T{\e_3}{A}}} 
    \arrow [r, "\bind{\e_1}{\e_2}{\T{\e_3}{A}}"]
    \arrow [d, "\T{\e_1}{\bind{\e_2}{\e_3}{A}}"] \& \T{\e_1 \dot \e_2}{\T{\e_3} A} \arrow [d, "\bind{\e_1 \dot \e_2}{\e_3}{A}"] \\
    \T{\e_1}{\T{\e_2 \dot \e_3}{A}} \arrow [r, "\bind{\e_1}{\e_2 \dot \e_3}{A}"] \& \T{\e_1 \dot \e_2 \dot \e_3}{A}    
\end{tikzcd}


\section{Tensor Strength}
Tensorial strength over a graded monad gives us the tools necessary to manipulate monadic operations in an intuitive way. Tensorial strength consists of a natural transformation:

\begin{align}
    \tstrength{\e}{A}{B}: A \times \teb \rightarrow \T{\e}{(A \times B)}
\end{align}

Such that the following diagrams commute:
\subsection{Left Naturality}
\begin{tikzcd}[ampersand replacement=\&]
    A \times \teb \arrow [r, "\Id{A} \times \T{\e}{f}"] \arrow [d, "\tstrength{\e}{A}{B}"]\&
    A \times \T{\e}{B'} \arrow [d, "\tstrength{\e}{A}{B'}"]\\
    \T{\e}{(A \times B)} \arrow [r, "\T{e}{(\Id{A} \times f)}"] \&
    \T{\e}{(A \times B')}
\end{tikzcd}

\subsection{Right Naturality}

\begin{tikzcd}[ampersand replacement=\&]
    A \times \teb  \arrow [r, "f \times \Id{\teb}"] \arrow [d, "\tstrength{\e}{A}{B}"]  \&
    A' \times \teb \arrow [d, "\tstrength {\e} {A'}{B}"]\\
    \T{\e}{(A \times B)} \arrow [r, "\T{\e}{(f \times \Id{B})}"]\&
    \T{\e}{(A' \times B)}
\end{tikzcd}

\subsection{Unitor Law}
\begin{tikzcd}[ampersand replacement=\&]
    \1 \times \tea 
    \arrow [r, "\tstrength{\e}{\1}{A}"]
    \arrow [rd, "\lambda_{\tea}"]
    \& 
    \T{\e}{(\1 \times A)}
    \arrow [d, "\T{\e}{(\lambda_A)}"]
    \\
    \&
    \tea
\end{tikzcd}
Where $\lambda: \terminal \times \Id{} \rightarrow \Id{}$ is the left-unitor.
($\lambda = \pp$)

\paragraph{Tensor Strength and Projection}
Due to the left-unitor law, we can develop a new law for the commutativity of $\pp$ with $\tstrength{}{}{}$

    $$\pi_{2, A, B} = \pi_{2, \1, B} \after (\term{A} \times \Id{B})$$

    And $\pi_{2, \1}$ is the left unitor, so by tensorial strength:
    
    \begin{equation}
        \begin{split}
            \T{\e}{\pp} \after \tstrength{\e}{A}{B} & = \T{\e}{\pi_{2, \1, B}} \after \T{\e}{(\term{A} \times \Id{B})} \after \tstrength{\e}{A}{B} \\
            & = \T{\e}{\pi_{2, 1, B}} \after \tstrength{\e}{\1}{B} \after (\term{A} \times \Id{B}) \\
            & = \pi_{2,1,B} \after (\term{A} \times \Id{B}) \\
            & = \pp
        \end{split}
    \end{equation}

So the following commutes:

\begin{tikzcd}[ampersand replacement=\&]
    A \times \teb 
    \arrow [r, "\tstrength{\e}{A}{B}"]
    \arrow [rd, "\pp"]
    \& 
    \T{\e}{(A \times B)}
    \arrow [d, "\T{\e}{\pp}"]
    \\
    \&
    \teb
\end{tikzcd}


\subsection{Commutativity with Join}
\begin{tikzcd}[ampersand replacement=\&]
    A \times \T{\e_1}{\T{\e_2}{B}} 
    \arrow [r, "\tstrength{\e_1}{A}{\T{\e_2}{B}}"]
    \arrow [dr, "\Id{A} \times \bind{\e_1}{\e_2}{B}"]
    \& 
    \T{\e_1}{(A \times \T{\e_2}{B})} 
    \arrow [r, "\T{\e_1}{\tstrength{\e_2}{A}{B}}"]
    \& 
    \T{\e_1}{\T{\e_2}{(A \times B)}} 
    \arrow [d, "\bind{\e_1}{\e_2}{A \times B}"]
    \\
    \&
    A \times \T{\e_1 \dot \e_2}{B}  
    \arrow [r, "\tstrength{\e_1 \dot \e_2}{A}{B}"] 
    \&
    \T{\e_1 \dot \e_2}({A \times B)}
\end{tikzcd}

\section{Commutativity with Unit}

\begin{tikzcd}[ampersand replacement=\&]
    A \times B
    \arrow [r, "\Id{A} \times \point{B}"]
    \arrow [rd, "\point{A \times B}"]
    \&
    A \times \tob 
    \arrow [d, "\tstrength{\1}{A}{B}"]
    \\
    \&
    \T{\1}{(A \times B)}
\end{tikzcd}

\section{Commutativity with $\alpha$}
Let $\alpha_{A, B, C} = \pr{\p\after\p}{\pr{\pp\after\p}{\pp}}: ((A \times B) \times C) \rightarrow (A \times (B \times C))$


\begin{tikzcd}[ampersand replacement=\&]
    (A\times B)\times \T{\e}{C} 
    \arrow [rr, "\tstrength{\e}{(A\times B)}{C}"]
    \arrow [d, "\alpha_{A, B, \T{\e}{C}}"]
    \& \& \T{\e}{((A \times B)\times C)}
    \arrow [d, "\T{\e}{\alpha_{A, B, C}}"]
    \\
    A \times (B \times \T{\e}{C}) 
    \arrow [r, "\Id{A}\times\tstrength{\e}{B}{C}"]
    \&
    A\times\T{\e}{(B \times C)} 
    \arrow [r, "\tstrength{\e}{A}{(B \times C)}"]
    \& \T{\e}{(A \times (B \times C))}
    \\
\end{tikzcd}


\section{Adjunction}
An important concept in category theory is that of an Adjunction.

Given functors F, G:

\begin{tikzcd}
    C \arrow[bend right=30]{rr}{F} & & D\arrow[bend right=30]{ll}{G}
\end{tikzcd}

And natural transformations:

\begin{itemize}
    \item Unit: $\eta_A: A \rightarrow G(F A)$ in $\C$
    \item Co-unit $\epsilon_B: F(G B) \rightarrow B$ in $\DC$
\end{itemize}

Such that 

\begin{align}
    \epsilon_{F A}\after F(\eta_A) & = \Id{F A} \\
    G(\epsilon_B)\after \eta_{F B} & = \Id{G B}
\end{align}

We can then use $\epsilon$ and $\eta$ to form a natural isomorphism between morphisms in the two categories.

\begin{align}
    \bar{(-)}: \quad\C(FA, B) &\leftrightarrow \DC(A, GB) \quad: \widehat{(-)}\\
     f & \mapsto G(f)\after\eta_A \\
     \epsilon\after F(g) & \mapsfrom g\\
\end{align}

\section{Strict Indexed Category}
The final piece of category theory required to understand this dissertation is the concept of a strictly indexed Category.

A strict indexed category is a functor from a base category into a target category of categories, such as the category of cartesian closed categories.

Objects in the base category are mapped to categories in the target category. Morphisms between objects in the base category are mapped to functors between categories in the target category.

For example, we may use the the case of cartesian closed categories indexed by a pre-order:

\begin{align}
    I: \mathbb{P} & \rightarrow \textit{CCCat}\qt{The indexing functor} \\
    A \in\obj\mathbb{P} & \mapsto \C \in\textit{CCCat}\qt{Objects are mapped to categories}\\
    A \leq B & \mapsto (A \leq B)\star: \C \rightarrow \DC\qt{Morphisms are mapped to functors preserving CCC properties.}
\end{align}


\end{document}