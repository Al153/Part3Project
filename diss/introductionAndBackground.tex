\documentclass{Report}
\usepackage{framed}

\input{../proofs/header.tex}

\begin{document}
\abstract


    
To date, there has been limited work on the semantics of languages with polymorphic effect systems. The application, by Moggi, of strong monads to modelling the semantics of effects has become a mainstream concept in functional programming languages. This was improved upon by Lucasson (?) using a graded monad to model languages with a range of independent and dependent effects at an operational level. A categorical semantics for parametric polymorphism in types was first published by Reynolds (?) allowing a denotational analysis of languages including type parameters. There has been some work on polymorphism over the exception effect (which paper). Despite these works, there has been no work to date on the denotational semantics of languages with general parametric polymorphism over effects.

In this dissertation, I present several pieces of work. Firstly, I shall introduce a modern definition of a lambda-calculus based language with an explicit graded monad to handle a variety of effects. This calculus shall then be extended using polymorphic terms to yield a more general polymorphic-effect-calculus. I shall then give an indexed-category-based denotational semantics for the language, along with an outline of a proof for the soundness of these semantics. Following this, I shall present a method of transforming a model of a non-polymorphic language into a model of the language with polymorphism over effects.

The full proofs can be found online on my github repository (link), since due to the number of theorems and cases, the total size is well over 100 pages of definitions, theorems, and proofs.

\chapter{Introduction}
\section{What is Effect Polymorphism?}
Effect polymorphism is when the same function in a language can operate on values of similar types but with different effects. It allows the same piece of code to be used in multiple contexts with different type signatures. This manifests in a similar manner to type parameter polymorphism in system-F based languages. Consider the following Scala-style pseudo-code:

\begin{framed}
    \begin{framed}
        \begin{verbatim}
def check[E: Effect](
    action: Unit => (Unit;e)
): Unit; (IO, e) {
    val ok: Boolean = promptBool(
        "Are you sure you want to do this?"
    )
    If (ok) {
        action()
    } else {
       abort()
    }
}  
            \end{verbatim}
    \end{framed}

    \begin{framed}
        \begin{verbatim}
check[RealWorld](() => check[RealWorld](FireMissiles))
check[Transaction](SendMoney(Bob, 100, USD))
check[Exception](ThrowException("Not Aborted"))
        \end{verbatim}
    \end{framed}
\end{framed}

In this case, we are reusing the same “check” function in three different cases with three different effects in a type safe manner. Hence, “check” is polymorphic in the effect parameter it receives. To analyse this language, it would be useful to have an analysis tool that can precisely model these separate, though potentially interdependent effects. A denotational semantics that can account for the parametric polymorphism over effects would be a step towards building such tools.

\section{An Introduction to Categorical Semantics}
A denotational semantics for a language is a mapping, known as a denotation, $\deno{-}$, of concepts in the language, such as types and terms to mathematical objects in such a way that non-trivial properties of the terms in the language correspond to other properties of the denotations of the terms.

When we specify a denotational semantics of a language in category theory, we look to find a mapping of types and typing environments to objects in a given category.

\begin{align}
    A: \type & \mapsto \deno{A} \in \obj \C \\
    \G & \mapsto  \deno{\G} \in \obj \C
\end{align}



Further more, instances of the type relation should be mapped to morphisms between the relevant objects.

\begin{align}
    \gtyperelation{v}{A} & \mapsto \C(\deno{\G}, \deno{A}) 
\end{align}

This should occur in a sound manner. That is, for every instance of the $\beta\eta$-equivalence relation between two terms, the denotations of the terms should be equal in the category.

\begin{align}
    \gberelation{v_1}{v_2}{A} & \implies \deno{\gtyperelation{v_1}{A}} = \deno{\gtyperelation{v_2}{A}}
\end{align}

To prove soundness, we induct over derivation of the $\beta\eta$-equivalence relation. In doing so, we need to prove a couple of properties which help prove cases. These are substitution and weakening. \todo{What do these do?}

\subsection{Languages and Their Requirements}
One of the simplest, while still interesting, languages to derive a denotational semantics for is the simply typed lambda calculus (STLC). STLC's semantics require a cartesian closed category (CCC, see section \ref{CCC}).

Products in the CCC are used to denote the lists of variable types in the typing environment, exponential objects model functions, and the terminal object is used to derive "points" (\todo{Terminology}) which represent the ground terms, such as the unit term, $()$, as well as the empty typing environment.


\begin{itemize}
    \item Products are used to construct type environments. $\deno{\G} = \deno{\nil, x: A, y:B, ... z:C} = \1 \times \deno{A} \times \deno{B} \times ... \times \deno{C}$
    \item Terminal objects are used in the denotation of constant terms $\deno{\gtyperelation{\const{A}}{A}} = \deno{\const{A}}\after\term{\deno{\G}}$
    \item Exponentials are used in the denotations of functions. $\deno{\typerelation{\G}{\lam{x}{A}{v}}{\ab}} = \cur{\deno{\typerelation{\gax}{v}{B}}}$
\end{itemize}

From this, we can specify what structures categories need to have in order to model more complex languages.
\begin{center}
    \begin{tabular}{|c|c|}
        \hline
        Language Feature & Structure Required \\
        \hline
        \hline
        STLC            & CCC \\
        \hline
        Single Effect   & Strong Monad \\
        \hline
        Multiple Effects & Strong Graded Monad \\
        \hline
        Polymorphism & Indexed Category \\
        \hline
    \end{tabular}
\end{center}


A single effect can be modelled by adding a strong monad to the category, as shown by Moggi \todo{Reference}. The monad allows us to generate a unit effect and to compose multiple instances of the effect together in a way that intuitively matches the type system of a monadic language.

\begin{eqnarray}\label{MonadTypeRules}
    \treerule{Return}{\typerelation{\G}{v}{A}}{\typerelation{\G}{\return{v}}{\M{}{A}}} & \treerule{Bind}{\typerelation{\G}{v_1}{\M{}{A}} \s\s \typerelation{\gax}{v_2}{\M{}{B}}}{\typerelation{\G}{\doin{x}{v_1}{v_2}}{\M{}{B}}}
\end{eqnarray}

These type rules can be modelled using the "unit" natural transformation and a combination of the "join" and tensor strength natural transformations respectively. 

For more precise analysis of languages with multiple effects, we can look into the algebra on the effects. A simple example of such an algebra is a partially ordered monoid. The monoid operation defines how to compose effects, and the partial order gives a sub-typing relation to make programming more intuitive with respect to if statements. A category with a strong graded monad allows us to model this algebra in a category theoretic way. It also allows us to do some effect analysis in the type system, as seen in the type rules for return and bind in equation \ref{GradedMonadTypeRules}.

\begin{eqnarray}\label{GradedMonadTypeRules}
    \treerule{Return}{\typerelation{\G}{v}{A}}{\typerelation{\G}{\return{v}}{\moa}} & \treerule{Bind}{\typerelation{\G}{v_1}{\M{\e_1}{A}} \s\s \typerelation{\gax}{v_2}{\M{\e_2}{B}}}{\typerelation{\G}{\doin{x}{v_1}{v_2}}{\M{\e_1 \dot \e_2}{B}}}
\end{eqnarray}


To express polymorphism over a property $P$, the language's semantics are expanded to use a new environment specifying the variables ranging over $P$ that are allowed in a given context. This can be seen in the augmented type rules in \ref{PolymorphismTypeRules}.

\begin{eqnarray}\label{PolymorphismTypeRules}
    \treerule{Gen}{\etyperelation{\P, \a}{v}{A}}{\gpetyperelation{\elam{\a}{v}}{\all{\a}{A}}}& \treerule{Spec}{\gpetyperelation{v}{\all{\a}{A}}\s\s\wellformed{\P}{\e}}{\gpetyperelation{\eapp{v}{\e}}{A\ssub{\a}{\e}}}
\end{eqnarray}

To model these augmented type rules, we can create a category representing the semantics of the non-polymorphic language at each given context. This collection of non-polymorphic categories can be indexed by a base category which models the operations and relationships between the $P$-Environment. Morphisms in the base category between environments correspond to functors between the semantic categories for the relevant environments. These functors can then be used to construct the semantics of polymorphic terms. \todo{Index diagram}

In this dissertation, I shall show how these category theoretic building blocks can be put together to give the class of categories that can model polymorphic effect systems.


\chapter{Required Category Theory}

Before going further, it is necessary to assert a common level of category theory knowledge. This section is not intended as a tutorial but as a to jog the memory of the reader, and briefly introduce some new concepts.

\section{Cartesian Closed Category}\label{CCC}

Recall that a category is cartesian closed if it has a terminal object, products for all pairs of objects, and exponentials.

\subsection{Terminal Object}
An object, $\1$, is terminal in a category, $\C$ if for all objects $X\in\obj\C$, there exists exactly one morphism $\term{X}: X \rightarrow \1$.

\subsection{Products}
There is a product for a pair of objects $X, Y\in\obj\C$ if there exists an object and morphisms in C:
\begin{tikzcd}
    X & \arrow{l}[swap]{\p} (X\times Y) \arrow [r, "\pp"] & Y
\end{tikzcd}

Such that for any other object and morphisms,

\begin{tikzcd}
    X & \arrow{l}[swap]{f} Z \arrow [r, "g"] & Y
\end{tikzcd}

There exists a unique morphism $\pr{f}{g}: Z \rightarrow (X\times Y)$ such that the following commutes:

\begin{tikzcd}
    & \arrow{dl}[swap]{f} Z  \arrow[d, "\pr{f}{g}"] \arrow [dr, "g"] & \\
    X & \arrow [l, "\p"] (X\times Y) \arrow{r}[swap]{\pp} & Y\\
\end{tikzcd}

\subsection{Exponentials}
A category has exponentials if for all objects $A, B$, it has an object $B^A$ and a morphism $\app: \B^A \times A \rightarrow B$ and for each $f: (A\times B)\rightarrow C$ in $\C$ there exists a unique morphism $\cur{f}: A \rightarrow C^B$ such that the following diagram commutes.

\begin{tikzcd}
    C^B \times B \arrow{r}{\app}& C\\
    A\times B\arrow{u}{\cur{f}\times \Id{B}} \arrow{ur}{f}    
\end{tikzcd}

\section{Co-Product}

\section{Functors}
A functor $F: \C \rightarrow \DC$ is a mapping of objects:
\begin{align}
    A\in\obj\C \mapsto FA \in \obj\DC
\end{align}

And morphisms:

\begin{align}
    f: \C(A, B) \mapsto F(f): \DC(FA, FB)
\end{align}

that preserves the category properties of composition and identity.

\begin{align}
    F(\Id{A}) & = \Id{FA} \\
    F(g\after f) & = F(g)\after F(f)
\end{align}

\section{Natural Transformations}

A natural transformation $\theta$ between to functors $F, G: \C \rightarrow \DC$ is a collection of morphisms, indexed by objects in $\C$ with  $\theta_A: F(A) \rightarrow G(A)$ such that following diagram commutes for each $f: A \rightarrow B \in \C$

\begin{tikzcd}
    F(A) \arrow{r}{\theta_A} \arrow{d}{F(f)}  & G(A) \arrow{d}{G(f)}\\
    F(B) \arrow{r}{\theta_B}& G(B)\\ 
\end{tikzcd}

\section{Monad}

A monad is famously "a monoid on the category of endofunctors". In less opaque terms, a monad is:

\begin{itemize}
    \item A functor from $\C$ onto itself. (An endofunctor) $T: \C \rightarrow C$
    \item A "unit" natural transformation $\point{A}: A\rightarrow T(A)$
    \item A "join" natural transformation $\mu_{A}: T(T(A)) \rightarrow T(A)$
\end{itemize}

Such that the following diagrams commute:

\subsection{Associativity}
\begin{tikzcd}
    T(T(T(A)) \arrow{r}{\mu_{T(A)}} \arrow{d}{T(\mu_{A})} & T(T(A)) \arrow{d}{\mu_A} \\
    T(T(A)) \arrow{r}{\mu_A} & T(A)    
\end{tikzcd}


\subsection{Left and Right Unit}
\begin{tikzcd}
    T(A) \arrow{r}{\point{T(A)}} \arrow{d}{T(\point{A})} \arrow[equal]{rd} & T(T(A)) \arrow{d}{\mu_A}\\
    T(T(A)) \arrow{r}{\mu_A} & T(A)
\end{tikzcd}



\section{Graded Monad}
A graded monad is a generalisation of a monad to be indexed by a monoidal algebra $E$. It is made up of:

\begin{itemize}
    \item An endo-functor indexed by a monoid: $\T{}{}: (\E, \dot\, \1)  \rightarrow [\C, \C]$
    \item A unit natural transformation: $\point{}: \Id{} \rightarrow \T{\1}{}$
    \item A join natural transformation: $\bind{\e_1}{\e_2}{}: \T{\e_1}{\T{\e_2}{}} \rightarrow \T{\e_1 \dot \e_2}{}$
\end{itemize}

Such that the following diagrams commute.:
\subsection{Left and Right  Units}
    \begin{tikzcd}[ampersand replacement=\&]
        \tea
         \arrow[equal]{rd} 
         \arrow[r, "\T{\e}{\point{A}}"]
         \arrow{d}{\point{\tea}}
        \& 
        \T{\e}{\T{\1}{A}} 
            \arrow[d, "\bind{\e}{\1}{A}"] \\
            \T{\1}{\T{\e}{A}}
                 \arrow{r}{\bind{\1}{\e}{A}}
        \& 
        \tea
    \end{tikzcd}

\subsection{Associativity}
\begin{tikzcd}[ampersand replacement=\&]
    \T{\e_1}{\T{\e_2}{\T{\e_3}{A}}} 
    \arrow [r, "\bind{\e_1}{\e_2}{\T{\e_3}{A}}"]
    \arrow [d, "\T{\e_1}{\bind{\e_2}{\e_3}{A}}"] \& \T{\e_1 \dot \e_2}{\T{\e_3} A} \arrow [d, "\bind{\e_1 \dot \e_2}{\e_3}{A}"] \\
    \T{\e_1}{\T{\e_2 \dot \e_3}{A}} \arrow [r, "\bind{\e_1}{\e_2 \dot \e_3}{A}"] \& \T{\e_1 \dot \e_2 \dot \e_3}{A}    
\end{tikzcd}


\section{Tensor Strength}
Tensorial strength over a graded monad gives us the tools necessary to manipulate monadic operations in an intuitive way. Tensorial strength consists of a natural transformation:

\begin{align}
    \tstrength{\e}{A}{B}: A \times \teb \rightarrow \T{\e}{(A \times B)}
\end{align}

Such that the following diagrams commute:
\subsection{Left Naturality}
\begin{tikzcd}[ampersand replacement=\&]
    A \times \teb \arrow [r, "\Id{A} \times \T{\e}{f}"] \arrow [d, "\tstrength{\e}{A}{B}"]\&
    A \times \T{\e}{B'} \arrow [d, "\tstrength{\e}{A}{B'}"]\\
    \T{\e}{(A \times B)} \arrow [r, "\T{e}{(\Id{A} \times f)}"] \&
    \T{\e}{(A \times B')}
\end{tikzcd}

\subsection{Right Naturality}

\begin{tikzcd}[ampersand replacement=\&]
    A \times \teb  \arrow [r, "f \times \Id{\teb}"] \arrow [d, "\tstrength{\e}{A}{B}"]  \&
    A' \times \teb \arrow [d, "\tstrength {\e} {A'}{B}"]\\
    \T{\e}{(A \times B)} \arrow [r, "\T{\e}{(f \times \Id{B})}"]\&
    \T{\e}{(A' \times B)}
\end{tikzcd}

\subsection{Unitor Law}
\begin{tikzcd}[ampersand replacement=\&]
    \1 \times \tea 
    \arrow [r, "\tstrength{\e}{\1}{A}"]
    \arrow [rd, "\lambda_{\tea}"]
    \& 
    \T{\e}{(\1 \times A)}
    \arrow [d, "\T{\e}{(\lambda_A)}"]
    \\
    \&
    \tea
\end{tikzcd}
Where $\lambda: \terminal \times \Id{} \rightarrow \Id{}$ is the left-unitor.
($\lambda = \pp$)

\paragraph{Tensor Strength and Projection}
Due to the left-unitor law, we can develop a new law for the commutativity of $\pp$ with $\tstrength{}{}{}$

    $$\pi_{2, A, B} = \pi_{2, \1, B} \after (\term{A} \times \Id{B})$$

    And $\pi_{2, \1}$ is the left unitor, so by tensorial strength:
    
    \begin{equation}
        \begin{split}
            \T{\e}{\pp} \after \tstrength{\e}{A}{B} & = \T{\e}{\pi_{2, \1, B}} \after \T{\e}{(\term{A} \times \Id{B})} \after \tstrength{\e}{A}{B} \\
            & = \T{\e}{\pi_{2, 1, B}} \after \tstrength{\e}{\1}{B} \after (\term{A} \times \Id{B}) \\
            & = \pi_{2,1,B} \after (\term{A} \times \Id{B}) \\
            & = \pp
        \end{split}
    \end{equation}

So the following commutes:

\begin{tikzcd}[ampersand replacement=\&]
    A \times \teb 
    \arrow [r, "\tstrength{\e}{A}{B}"]
    \arrow [rd, "\pp"]
    \& 
    \T{\e}{(A \times B)}
    \arrow [d, "\T{\e}{\pp}"]
    \\
    \&
    \teb
\end{tikzcd}


\subsection{Commutativity with Join}
\begin{tikzcd}[ampersand replacement=\&]
    A \times \T{\e_1}{\T{\e_2}{B}} 
    \arrow [r, "\tstrength{\e_1}{A}{\T{\e_2}{B}}"]
    \arrow [dr, "\Id{A} \times \bind{\e_1}{\e_2}{B}"]
    \& 
    \T{\e_1}{(A \times \T{\e_2}{B})} 
    \arrow [r, "\T{\e_1}{\tstrength{\e_2}{A}{B}}"]
    \& 
    \T{\e_1}{\T{\e_2}{(A \times B)}} 
    \arrow [d, "\bind{\e_1}{\e_2}{A \times B}"]
    \\
    \&
    A \times \T{\e_1 \dot \e_2}{B}  
    \arrow [r, "\tstrength{\e_1 \dot \e_2}{A}{B}"] 
    \&
    \T{\e_1 \dot \e_2}({A \times B)}
\end{tikzcd}

\section{Commutativity with Unit}

\begin{tikzcd}[ampersand replacement=\&]
    A \times B
    \arrow [r, "\Id{A} \times \point{B}"]
    \arrow [rd, "\point{A \times B}"]
    \&
    A \times \tob 
    \arrow [d, "\tstrength{\1}{A}{B}"]
    \\
    \&
    \T{\1}{(A \times B)}
\end{tikzcd}

\section{Commutativity with $\alpha$}
Let $\alpha_{A, B, C} = \pr{\p\after\p}{\pr{\pp\after\p}{\pp}}: ((A \times B) \times C) \rightarrow (A \times (B \times C))$


\begin{tikzcd}[ampersand replacement=\&]
    (A\times B)\times \T{\e}{C} 
    \arrow [rr, "\tstrength{\e}{(A\times B)}{C}"]
    \arrow [d, "\alpha_{A, B, \T{\e}{C}}"]
    \& \& \T{\e}{((A \times B)\times C)}
    \arrow [d, "\T{\e}{\alpha_{A, B, C}}"]
    \\
    A \times (B \times \T{\e}{C}) 
    \arrow [r, "\Id{A}\times\tstrength{\e}{B}{C}"]
    \&
    A\times\T{\e}{(B \times C)} 
    \arrow [r, "\tstrength{\e}{A}{(B \times C)}"]
    \& \T{\e}{(A \times (B \times C))}
    \\
\end{tikzcd}


\section{Adjunction}
An important concept in category theory is that of an Adjunction.

Given functors F, G:

\begin{tikzcd}
    C \arrow[bend right=30]{rr}{F} & & D\arrow[bend right=30]{ll}{G}
\end{tikzcd}

And natural transformations:

\begin{itemize}
    \item Unit: $\eta_A: A \rightarrow G(F A)$ in $\C$
    \item Co-unit $\epsilon_B: F(G B) \rightarrow B$ in $\DC$
\end{itemize}

Such that 

\begin{align}
    \epsilon_{F A}\after F(\eta_A) & = \Id{F A} \\
    G(\epsilon_B)\after \eta_{F B} & = \Id{G B}
\end{align}

We can then use $\epsilon$ and $\eta$ to form a natural isomorphism between morphisms in the two categories.

\begin{align}
    \bar{(-)}: \quad\C(FA, B) &\leftrightarrow \DC(A, GB) \quad: \widehat{(-)}\\
     f & \mapsto G(f)\after\eta_A \\
     \epsilon\after F(g) & \mapsfrom g\\
\end{align}

\section{Strict Indexed Category}
The final piece of category theory required to understand this dissertation is the concept of a strictly indexed Category.

A strict indexed category is a functor from a base category into a target category of categories, such as the category of cartesian closed categories.

Objects in the base category are mapped to categories in the target category. Morphisms between objects in the base category are mapped to functors between categories in the target category.

For example, we may use the the case of cartesian closed categories indexed by a pre-order:

\begin{align}
    I: \mathbb{P} & \rightarrow \textit{CCCat}\qt{The indexing functor} \\
    A \in\obj\mathbb{P} & \mapsto \C \in\textit{CCCat}\qt{Objects are mapped to categories}\\
    A \leq B & \mapsto (A \leq B)\star: \C \rightarrow \DC\qt{Morphisms are mapped to functors preserving CCC properties.}
\end{align}

\section{Limits}

\end{document}