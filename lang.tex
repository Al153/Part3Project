\documentclass[twoside,a4paper,11pt]{article}
\usepackage{amsmath}
\usepackage[a4paper,includeheadfoot,margin=2.54cm]{geometry}
\usepackage{breqn}
\usepackage{stmaryrd}
\usepackage{amssymb}

\newcommand{\s}{\mbox{ }}
\newcommand{\subtype}{\leq}
\newcommand{\subeffect}{\sqsubseteq}

\newcommand{\typeJudgement}[2]{\Gamma\vdash #1 \colon #2}
\newcommand{\modVarTypeJudgement}[3]{\Gamma, #1 \vdash #2 \colon #3}
\newcommand{\conditionalTypeRule}[4]{\typeRule{#1}{#2}{#3} #4}
\newcommand{\typeRule}[3]{\displaystyle\mbox{#1}\frac{#2}{#3}}


\newcommand{\db}[1]{{\bf [\![}#1{\bf ]\!]}}
\newcommand{\deno}[1]{\db{#1}(v)}
\newcommand{\setComp}[2]{\left\lbrace #1 \mid #2 \right\rbrace}
\newcommand{\clos}[0]{closure(A, v)}






\newcommand{\denoRule}[2]{#1 \in \deno{#2}}
\newcommand{\opRule}[3]{#1 \triangleleft_{#2, v} #3}

\newcommand{\phiRule}[3]{\Phi(\Sigma, #1, #2, #3)}
\newcommand{\psiRule}[2]{\Psi(\Sigma, #1, #2)}

\begin{document}

\section{Semantics}
\subsection{Grammar and definitions}

\paragraph{Value expressions}

\begin{equation}
\label{PDefifinition}
\begin{split}
V  &\rightarrow C^{\gamma} \mbox{ Typed contants}\\
&\mid () \mbox{ Unit constructor}\\
&\mid \lambda x: \tau. M \mbox{ term lambda expressions}\\
&\mid x \mbox{ Variables}\\
&\mid \Lambda \phi. V \mbox{ Effect lambda expressions}\\
&\mid V \epsilon \mbox{ Effect specialisation}\\
\end{split}
\end{equation} 

\paragraph{Computation expressions}
todo: is the if rule necessary?
\begin{equation}
\label{PDefifinition}
\begin{split}
M & \rightarrow V \s V \mbox{Application}\\
&\mid do \s x \s \leftarrow \s M \s in \s M \mbox{ Sequencing}\\
&\mid return\s V \mbox{ Unit computation}\\
&\mid if\s V\s then\s C \s else \s C \mbox{ Conditional}\\
&\mid Cons^{\tau_1 \rightarrow T_{\xi} \tau_2}(V) \mbox{ Computation Constructors}\\
&\mid Op^{T_{\xi} \tau_1 \rightarrow T_{\xi} \tau_2}(M) \mbox{ Computation Combinators}\\
\end{split}
\end{equation} 

\paragraph{Value types}
\begin{equation}
\label{PDefifinition}
\begin{split}
\tau & \rightarrow \gamma \mbox{ Ground Types}\\
&\mid \tau \rightarrow \Theta \mbox{ Functions are kleisli arrows}\\
&\mid \forall \phi. \tau \mbox{ Effect quantification}\\
\end{split}
\end{equation} 

\paragraph{Computation (Monad) types}
\begin{equation}
\label{PDefifinition}
\begin{split}
\Theta & \rightarrow T _\epsilon \tau \mbox{ Monad type constructor}\\
\end{split}
\end{equation} 


\paragraph{Effects}

$$ \epsilon \rightarrow \phi \mid \xi .. \mbox{ Effect variables or ground effects}$$

\subsection{typing}

\paragraph{Value typing rules}
\[ \begin{array}{c}
\typeRule{(Const)}{\Gamma\s OK}{\typeJudgement{C^{\gamma}}{\gamma}} \\[3ex]

\typeRule{(Unit)}{\Gamma\s OK}{\typeJudgement{()}{unit}} \\[3ex]

\conditionalTypeRule{(Weaken)}{\typeJudgement{x}{A}}{\modVarTypeJudgement{x' : A'}{x}{A}}{(x \neq x')} \\[3ex]

\typeRule{(Var)}{\Gamma\s OK}{\modVarTypeJudgement{x: A}{x}{A}} \\[3ex]

\conditionalTypeRule{(Eff-Gen)}{\typeJudgement{V}{A}}{\typeJudgement{\Lambda \phi. V}{\forall \phi. A}}{\phi \not\in fev(\Gamma)} \\[3ex]

\typeRule{(Eff-Spec)}{\typeJudgement{V}{\forall \phi. A}}{\typeJudgement{V \epsilon}{A {[\epsilon \phi] }}} \\[3ex]

\conditionalTypeRule{(Lambda)}{\modVarTypeJudgement{x: A}{M}{\Theta}}{\typeJudgement{\lambda x : A. M}{A  \rightarrow \Theta}}{x \not\in fv(\Gamma)}
\\[3ex]
\conditionalTypeRule{(SubType)}{\typeJudgement{V}{A}}{\typeJudgement{V}{B}}{A \subtype B}
\end{array} \]

\paragraph{Computation Typing Rules}

\[\begin{array}{c}
\typeRule{(Application)}{\typeJudgement{V_1}{A \rightarrow \Theta}\s\typeJudgement{V_2}{A}}{\typeJudgement{V_1 V_2}{\Theta}}
\\
\typeRule{(Sequencing)}{\typeJudgement{M_1}{T_{\epsilon_1} A}\s\modVarTypeJudgement{x: A}{M_2}{T_{\epsilon_2} B}}{\typeJudgement{do \s x \s \leftarrow \s M_1 \s in \s M_2}{T_{\epsilon_1 \circ \epsilon_2} B}}
\\
\typeRule{(Unit Computation)}{\typeJudgement{V}{A}}{\typeJudgement{return(V)}{T_{1}A}}
\\
\typeRule{(Constructor)}{\typeJudgement{V}{\tau_1}}{\typeJudgement{ Cons^{\tau_1 \rightarrow T_{\xi} \tau_2}(V)}{T_{\xi} \tau_2}}
\\
\typeRule{(Combinator)}{\typeJudgement{M}{{T_{\xi_1} \tau_1}}}{\typeJudgement{ Op^{T_{\xi} \tau_1 \rightarrow T_{\xi} \tau_2}(M)}{{T_{\xi_2} \tau_2}}}
\\
\typeRule{(if)}{\typeJudgement{V}{Bool}\s\typeJudgement{C_1}{\Theta}\s\typeJudgement{C_2}{\Theta}}{\typeJudgement{if\s V\s then\s C_1\s else \s C_2}{\Theta}}
\\
\conditionalTypeRule{(SubTypeC)}{\typeJudgement{M}{\Theta_1}}{\typeJudgement{M}{\Theta_2}}{\Theta_2 \subtype \Theta_1}
\end{array}\]

\paragraph{Subtyping Rules}

$A$ ranges over value types
\[\begin{array}{c}

\typeRule{(Reflexive)}{}{A \subtype A}
\\
\\
\typeRule{(Transitive)}{A \subtype B\s B\subtype C}{A \subtype C}
\\
\\
\typeRule{(Function)}{A' \subtype A \s\s \Theta\subtype \Theta'}{A \rightarrow \Theta \subtype A' \rightarrow \Theta'}
\\
\\
\typeRule{(Quantification)}{\tau_1 \subtype \tau_2}{\Lambda \phi. \tau_1 \subtype \Lambda \phi. \tau_2}
\\
\\
\typeRule{(Computation)}{\epsilon_1 \subeffect \epsilon_2\s\s A \subtype B}{T_{\epsilon_1} A \subtype T_{\epsilon_2} B}

\end{array}\]



\end{document}