\documentclass[twoside,a4paper,11pt]{article}
\usepackage{amsmath}
\usepackage[a4paper,includeheadfoot,margin=2.54cm]{geometry}
\usepackage{breqn}
\usepackage{stmaryrd}
\usepackage{amssymb}

\newcommand{\s}{\mbox{ }}
\newcommand{\subtype}{\leq}
\newcommand{\subeffect}{\sqsubseteq}

\newcommand{\typeJudgement}[2]{\Gamma\vdash #1 \colon #2}
\newcommand{\modVarTypeJudgement}[3]{\Gamma, #1 \vdash #2 \colon #3}
\newcommand{\conditionalrule}[4]{\syntaxRule{#1}{#2}{#3} #4}
\newcommand{\syntaxRule}[3]{\displaystyle\mbox{#1}\frac{#2}{#3}}


\newcommand{\sub}[2]{\left[^{#1}/_{#2}\right]}

\newcommand{\db}[1]{{\bf [\![}#1{\bf ]\!]}}
\newcommand{\deno}[1]{\db{#1}(v)}
\newcommand{\setComp}[2]{\left\lbrace #1 \mid #2 \right\rbrace}
\newcommand{\clos}[0]{closure(A, v)}

\newcommand{\goesTo}[3]{#1 \Downarrow_{\text{#3}} #2}
\newcommand{\esPair}[2]{\left\langle #1, #2 \right\rangle}


\begin{document}

\section{Semantics}
\subsection{Grammar and definitions}

\paragraph{Value expressions}

\begin{equation}
\label{PDefifinition}
\begin{split}
V  &\rightarrow C^{\gamma} \mbox{ Typed contants}\\
&\mid () \mbox{ Unit constructor}\\
&\mid \lambda x: \tau. M \mbox{ term lambda expressions}\\
&\mid x \mbox{ Variables}\\
&\mid \Lambda \phi. V \mbox{ Effect lambda expressions}\\
&\mid V \epsilon \mbox{ Effect specialisation}\\
\end{split}
\end{equation} 

\paragraph{Computation expressions}
todo: is the if rule necessary?
\begin{equation}
\label{PDefifinition}
\begin{split}
M & \rightarrow V \s V \mbox{Application}\\
&\mid do \s x \s \leftarrow \s M \s in \s M \mbox{ Sequencing}\\
&\mid return\s V \mbox{ Unit computation}\\
&\mid if\s V\s then\s C \s else \s C \mbox{ Conditional}\\
&\mid Cons^{\tau_1 \rightarrow T_{\xi} \tau_2}(V) \mbox{ Computation Constructors}\\
&\mid Op^{T_{\xi} \tau_1 \rightarrow T_{\xi} \tau_2}(M) \mbox{ Computation Combinators}\\
\end{split}
\end{equation} 

\paragraph{Value types}
\begin{equation}
\label{PDefifinition}
\begin{split}
\tau & \rightarrow \gamma \mbox{ Ground Types}\\
&\mid \tau \rightarrow \Theta \mbox{ Functions are kleisli arrows}\\
&\mid \forall \phi. \tau \mbox{ Effect quantification}\\
\end{split}
\end{equation} 

\paragraph{Computation (Monad) types}
\begin{equation}
\label{PDefifinition}
\begin{split}
\Theta & \rightarrow T _\epsilon \tau \mbox{ Monad type constructor}\\
\end{split}
\end{equation} 


\paragraph{Effects}

$$ \epsilon \rightarrow \phi \mid \xi .. \mbox{ Effect variables or ground effects}$$

\subsection{typing}

\paragraph{Value typing rules}
\[ \begin{array}{c}
\syntaxRule{(Const)}{\Gamma\s OK}{\typeJudgement{C^{\gamma}}{\gamma}} \\[3ex]

\syntaxRule{(Unit)}{\Gamma\s OK}{\typeJudgement{()}{unit}} \\[3ex]

\conditionalrule{(Weaken)}{\typeJudgement{x}{A}}{\modVarTypeJudgement{x' : A'}{x}{A}}{(x \neq x')} \\[3ex]

\syntaxRule{(Var)}{\Gamma\s OK}{\modVarTypeJudgement{x: A}{x}{A}} \\[3ex]

\conditionalrule{(Eff-Gen)}{\typeJudgement{V}{A}}{\typeJudgement{\Lambda \phi. V}{\forall \phi. A}}{\phi \not\in fev(\Gamma)} \\[3ex]

\syntaxRule{(Eff-Spec)}{\typeJudgement{V}{\forall \phi. A}}{\typeJudgement{V \epsilon}{A {[\epsilon \phi] }}} \\[3ex]

\conditionalrule{(Lambda)}{\modVarTypeJudgement{x: A}{M}{\Theta}}{\typeJudgement{\lambda x : A. M}{A  \rightarrow \Theta}}{x \not\in fv(\Gamma)}
\\[3ex]
\conditionalrule{(SubType)}{\typeJudgement{V}{A}}{\typeJudgement{V}{B}}{A \subtype B}
\end{array} \]

\paragraph{Computation Typing Rules}

\[\begin{array}{c}
\syntaxRule{(Application)}{\typeJudgement{V_1}{A \rightarrow \Theta}\s\typeJudgement{V_2}{A}}{\typeJudgement{V_1 V_2}{\Theta}}
\\
\syntaxRule{(Sequencing)}{\typeJudgement{M_1}{T_{\epsilon_1} A}\s\modVarTypeJudgement{x: A}{M_2}{T_{\epsilon_2} B}}{\typeJudgement{do \s x \s \leftarrow \s M_1 \s in \s M_2}{T_{\epsilon_1 \circ \epsilon_2} B}}
\\
\syntaxRule{(Unit Computation)}{\typeJudgement{V}{A}}{\typeJudgement{return(V)}{T_{1}A}}
\\
\syntaxRule{(Constructor)}{\typeJudgement{V}{\tau_1}}{\typeJudgement{ Cons^{\tau_1 \rightarrow T_{\xi} \tau_2}(V)}{T_{\xi} \tau_2}}
\\
\syntaxRule{(Combinator)}{\typeJudgement{M}{{T_{\xi_1} \tau_1}}}{\typeJudgement{ Op^{T_{\xi} \tau_1 \rightarrow T_{\xi} \tau_2}(M)}{{T_{\xi_2} \tau_2}}}
\\
\syntaxRule{(if)}{\typeJudgement{V}{Bool}\s\typeJudgement{C_1}{\Theta}\s\typeJudgement{C_2}{\Theta}}{\typeJudgement{if\s V\s then\s C_1\s else \s C_2}{\Theta}}
\\
\conditionalrule{(SubTypeC)}{\typeJudgement{M}{\Theta_1}}{\typeJudgement{M}{\Theta_2}}{\Theta_2 \subtype \Theta_1}
\end{array}\]

\paragraph{Subtyping Rules}

$A$ ranges over value types
\[\begin{array}{c}

\syntaxRule{(Reflexive)}{}{A \subtype A}
\\
\\
\syntaxRule{(Transitive)}{A \subtype B\s B\subtype C}{A \subtype C}
\\
\\
\syntaxRule{(Function)}{A' \subtype A \s\s \Theta\subtype \Theta'}{A \rightarrow \Theta \subtype A' \rightarrow \Theta'}
\\
\\
\syntaxRule{(Quantification)}{\tau_1 \subtype \tau_2}{\Lambda \phi. \tau_1 \subtype \Lambda \phi. \tau_2}
\\
\\
\syntaxRule{(Computation)}{\epsilon_1 \subeffect \epsilon_2\s\s A \subtype B}{T_{\epsilon_1} A \subtype T_{\epsilon_2} B}

\end{array}\]

\subsection{Operational Semantics}

\begin{equation}
\begin{array}{c}

\syntaxRule{(Gen)}{\goesTo{V}{V'}{v}}{\goesTo{\Lambda \phi. V}{V'}{v}}
 \\

\syntaxRule{(Spec)}{\goesTo{V}{V'}{v}}{\goesTo{V \phi}{V'}{v}}

\end{array}
\end{equation}

\begin{equation}
\begin{array}{c}

\syntaxRule{(app1)}{\goesTo{V_1}{V'_1}{v}}{\goesTo{V_1\s V_2}{V'_1\s V_2}{todo}}
 \\\\
 
 \syntaxRule{(app2)}{\goesTo{V_2}{V'_2}{v}}{\goesTo{\lambda x: \tau. C_1\s V_2}{\lambda x: \tau. C_1\s V'_2}{todo}}
 \\\\
 
 
\syntaxRule{(App)}
{\goesTo{V_1}{\lambda x: \tau. C_1}{v}\s\s \goesTo{V_2 }{V'_2}{v}\s\s \goesTo{C_1 \sub{V_2}{x}}{C'_1}{$\epsilon$}}{\goesTo{V_1\s V_2}{C'_1}{$\epsilon$}}
\\
\\

\\syntaxRule{(Bind)}

\end{array}
\end{equation}

\end{document}